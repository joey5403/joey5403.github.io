<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Improving flag usage in code | 黄庄以北</title>
<meta name=keywords content="feature toggle"><meta name=description content="Improving flag usage in code Read time: 10 minutes Last edited: Sep 18, 2024 Overview This guide provides best practices and suggestions for improving code that uses feature flags. These practices can improve both code quality and ease of maintenance. You can use code in tandem with your feature flags to maintain and improve the resilience of your process, including improving flag hygiene, giving your team more flexibility, refactoring flagged"><meta name=author content="Joey"><link rel=canonical href=https://joeyzheng.tech/posts/improving-flag-usage-in-code/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://joeyzheng.tech/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://joeyzheng.tech/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://joeyzheng.tech/favicon-32x32.png><link rel=apple-touch-icon href=https://joeyzheng.tech/apple-touch-icon.png><link rel=mask-icon href=https://joeyzheng.tech/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://joeyzheng.tech/posts/improving-flag-usage-in-code/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="https://joeyzheng.tech/posts/improving-flag-usage-in-code/"><meta property="og:site_name" content="黄庄以北"><meta property="og:title" content="Improving flag usage in code"><meta property="og:description" content="Improving flag usage in code Read time: 10 minutes Last edited: Sep 18, 2024 Overview This guide provides best practices and suggestions for improving code that uses feature flags. These practices can improve both code quality and ease of maintenance. You can use code in tandem with your feature flags to maintain and improve the resilience of your process, including improving flag hygiene, giving your team more flexibility, refactoring flagged"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-10-20T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-20T00:00:00+00:00"><meta property="article:tag" content="Feature Toggle"><meta name=twitter:card content="summary"><meta name=twitter:title content="Improving flag usage in code"><meta name=twitter:description content="Improving flag usage in code Read time: 10 minutes Last edited: Sep 18, 2024 Overview This guide provides best practices and suggestions for improving code that uses feature flags. These practices can improve both code quality and ease of maintenance. You can use code in tandem with your feature flags to maintain and improve the resilience of your process, including improving flag hygiene, giving your team more flexibility, refactoring flagged"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://joeyzheng.tech/posts/"},{"@type":"ListItem","position":2,"name":"Improving flag usage in code","item":"https://joeyzheng.tech/posts/improving-flag-usage-in-code/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Improving flag usage in code","name":"Improving flag usage in code","description":"Improving flag usage in code Read time: 10 minutes Last edited: Sep 18, 2024 Overview This guide provides best practices and suggestions for improving code that uses feature flags. These practices can improve both code quality and ease of maintenance. You can use code in tandem with your feature flags to maintain and improve the resilience of your process, including improving flag hygiene, giving your team more flexibility, refactoring flagged","keywords":["feature toggle"],"articleBody":"Improving flag usage in code Read time: 10 minutes Last edited: Sep 18, 2024 Overview This guide provides best practices and suggestions for improving code that uses feature flags. These practices can improve both code quality and ease of maintenance.\nYou can use code in tandem with your feature flags to maintain and improve the resilience of your process, including improving flag hygiene, giving your team more flexibility, refactoring flagged code to the degree that you need and no further, and generally increasing code quality.\nNot all best practices work for everyone\nThe practices we offer in this guide are subjective. What may be a best practice for one team may not work as well for another. Review the recommendations in this guide and consider carefully if they will help your team before you implement them.\nConcepts In order to use this guide effectively, you should understand these concepts:\nImprove flag hygiene Most of the flags added to a project are temporary, intended to be removed later. Unfortunately, most teams are worse at removing flags than adding them, because removal is usually less urgent. This can lead to a codebase cluttered with flags that are no longer relevant. At best, this makes the code harder to read; at worst, inadvertently toggling the wrong flag can cause production failures.\nTeams that use flags need to ensure that their code only references flags which are currently in use. This practice is known as “flag hygiene.” Here is a selection of techniques that help maintain good flag hygiene.\nTo learn more about flag hygiene, read Reducing technical debt from feature flags .\nExtend your team’s “definition of done” Engineering teams maintain their own standards for when a task or project can be considered “done.” For example, a team may consider the code for a task to be incomplete until it has automated tests.\nYou can maintain flag hygiene by ensuring that the temporary flags created for a task or project are no longer referenced by any code and are archived after they’re no longer in use. Adding this as a requirement to your team’s definition of done may help streamline your codebase, because only the flags you’re actively using will be present in it.\nCode standards are easier to maintain with automated checks, such as those performed by a continuous integration (CI) system. You can even automate some flag hygiene checks.\nUse code references to track flag hygiene LaunchDarkly’s code references feature keeps track of the places in your code where each flag appears. It’s particularly useful when you need to clean up old flags.\nEnsure that the code references for your project are up to date by integrating the ld-find-code-refs tool with your code pipeline.\nTo learn more, read Code references .\nHere is an image of the code references section for a feature flag:\nThe code references section of a feature flag.\nRefactor flagged code to reduce merge conflicts Merge conflicts are a common source of friction when you make code changes. Adding flag logic in the middle of a function increases the chances that both that addition and its removal later will conflict with other changes.\nTo reduce the chance of conflicts, refactor both the flag logic and the code for each variation into their own functions. Keep the refactoring simple so that the overall time spent implementing the flag is short.\nThe examples below do not use a real coding language\nThe examples below use an approximation of a real coding language to illustrate the concepts they express. The language is based on JavaScript, but is not JavaScript.\nDo not use these code samples in a production environment. They will not work.\nHere’s an example to demonstrate this factoring tactic. The example code is taken from a fictional app which has a search feature which queries a back-end search engine. In the existing code, the function getSearchResults does the work of sending the search query to the backend, checking for errors and fetching the results.\nHere is an example:\npseudocode\nfunction getSearchResults(query, context) {\n// 1. parse the query so engine can use it\n// … query parsing logic goes here…\n// 2. send the search query to the back-end search engine\nengineURL = SEARCH_ENGINE_URL + ‘/search’;\nresponse = sendRequest(engineURL, parsedQuery);\n// 3. check for errors\nif (response.body.starts_with(“SEARCH ERROR”)) {\n// if there's an error, log the response and context details log.ERROR(\"Search failure\", response, context); return new Error(\"There was an internal search error.\"); } else {\n// 4. turn response into a result list, clean up the results, etc. // ... results logic goes here... return results; }\n}\nCOPY\nThe app’s engineering team is preparing to migrate to a new, improved search engine. To prepare for the migration, the team has created the flag use-new-search-engine to tell the app which search back-end to use. The code needs to include code for querying both the old and the new search engines.\nInserting the flag logic in the middle of getSearchResults would make it even more complicated than it is already. Instead, they extract the relevant code and move it to new functions. They take the code which sends the query to the search engine (section 2 in the code above) and also code which processes errors and results (sections 3 and 4), because the new engine returns errors and results in a different format.\nThe team moves these lines of code, along with code for the new search engine and code to check the flag, into their own functions:\npseudocode\n// This new version of the main function is much shorter,\n// because it delegates the central work to executeSearch()\nfunction getSearchResults(query, context) {\n// 1. parse the query so engine can use it\n// … query parsing logic goes here…\n// 2. send the search query to the back-end search engine\nresponse = executeSearch(parsedQuery, context);\nreturn response;\n}\n// This function only checks the value of the “use-new-search-engine” flag\n// and routes the query to one of the two functions below\n// to do the actual querying and processing\nfunction executeSearch(query, context) {\nuseNewEngine = ldclient.variation(“use-new-search-engine”, context, false);\nif (useNewEngine == true) {\nreturn queryNewEngine(query, context); } else {\nreturn queryOldEngine(query, context); }\n}\n// This function queries the OLD search engine and processes the response\nfunction queryOldEngine(query, context) {\nengineURL = SEARCH_ENGINE_URL + ‘/search’;\nresponse = sendRequest(engineURL, query);\nif (response.body.starts_with(“SEARCH ERROR”)) {\nlog.ERROR(\"Search failure on old engine\", response, context); return new Error(\"There was an internal search error.\"); } else {\n// turn response into result list, clean up the results, etc. // ... results logic goes here... return results; }\n}\n// This function queries the NEW search engine and processes the response\nfunction queryNewEngine(query, context) {\nengineURL = NEW_SEARCH_ENGINE_URL + ‘/query’;\nresponse = sendRequest(engineURL, query);\nif (response.type == “error”) {\nlog.ERROR(\"Search failure on new engine\", response, context); return new Error(\"There was an internal search error.\"); } else {\n// turn new-engine response into a result list // ... results logic goes here... return results; }\n}\nCOPY\nThe migration is expected to last a few weeks. Because the new feature is wrapped in a feature flag, the team can integrate the new search engine code before it’s been fully tested and optimized. Now, they can spend time improving the code with real production data. Because the new and old search engine code is separated into different functions, they can make those improvements without changing shared code. In addition, it’s easier to add unit tests for the new code because they can call it directly without needing to create mock flag states.\nWhen it’s time to retire the old search engine and archive the feature flag, the cleanup is minimal and less likely to cause merge conflicts.\nThe cleanup steps are:\nDelete the executeSearch and queryOldEngine functions. Rename queryNewEngine to executeSearch. Within queryNewEngine, change the log.ERROR message from \"Search failure on new engine\" to just \"Search failure\", because there is only one engine now. Avoid additional refactoring Both queryOldEngine and queryNewEngine contain similar code. Another version of this example could even contain more lines of code which are duplicated between both functions. You might want to refactor further by moving the duplicated code into a shared function.\nThere are a couple of reasons not to deduplicate code.\nThe code is not intended for long-term maintenance. After the migration is finished, the duplicates are deleted. There is likely to be short-term maintenance as you improve queryNewEngine. Premature refactoring may hinder that maintenance more than it helps. We recommend the common refactoring adage known as the rule of three : don’t refactor for deduplication until code is duplicated three or more times.\nImprove code quality Adding feature flags to code increases its flexibility, but can also add complexity. The more complex your code is, the more difficult it is to diagnose and correct an unexpected problem.\nThere are various techniques you can use to make sure that your feature flags help accomplish what you want to do with code.\nHere are some guidelines you can follow to make sure you write high-quality code:\nAvoid passing flag state in a call interface When you use a feature flag to change the behavior of a component, perform the flag evaluation inside the component.\nIt can be tempting to add a dedicated parameter to the call interface and send the flag state from the outside. However, changing the component’s interface means that all the component’s callers have to be changed too, and then changed again once the flag is removed.\nConsider the executeSearch function we used as an example earlier. It calls ldclient.variation to evaluate the flag from within its own implementation.\nIf we moved that call out to getSearchResults and sent the flag value to executeSearch as an argument, the abbreviated code would look like this:\npseudocode\nfunction getSearchResults(query, context) {\n// 1. parse the query so engine can use it\n// … query parsing logic goes here…\n// 2. send the search query to the back-end search engine\n// with the feature flag value\nuseNewEngine = ldclient.variation(“use-new-search-engine”, context, false);\nresponse = executeSearch(parsedQuery, context, useNewEngine);\nreturn response;\n}\n// useNewEngine is now supplied in the call\nfunction executeSearch(query, context, useNewEngine) {\nif (useNewEngine == true) {\nreturn queryNewEngine(query, context); } else {\nreturn queryOldEngine(query, context); }\n}\nCOPY\nThe purpose of our flag-oriented refactoring was to reduce merge conflicts by separating out the code that would need to change, and keeping it contained in dedicated functions. Unfortunately, putting the flag evaluation code in getSearchResults has given it more responsibility that it didn’t need, and removed the benefits of the refactoring.\nIn this example, the changed interface only had one caller. When changing functions and modules with many callers, there’s even greater benefit in keeping the interface the same. This is especially important given the other risks inherent in changing heavily-used code.\nFlags can change any time The more frequently that your code is executed, the more likely it is that your code will be in the middle of executing when a vital flag is changed. If your code is constructed in a way that expects flag state to stay consistent between the start and end of a code path, it can cause problems that are particularly hard to debug.\nOne way to avoid this problem is to use LaunchDarkly’s custom roles feature to restrict who can access the flag.\nTo learn more, read Custom roles .\nThis can make it harder to change a flag, which can be good in some cases, but it also increases the friction in your development process. Instead of making change more difficult, it’s better to improve the robustness of your code.\nThe following example uses a service that sends batches of data through a processing pipeline. Each batch must go through three processing steps: normalization, relabeling, and storage.\nA dedicated service performs each of these steps. The storage step is always the last, but the normalization and relabeling can happen in either order. Each service is responsible for sending the data batch to the next service.\nThere are two possible orders in which the processing steps can be performed. The order is chosen using a feature flag called process-order which has variations normalize-first and relabel-first.\nThe normalize-first order is:\nNormalization Relabeling Storage The relabel-first order looks like this:\nRelabeling Normalization Storage Each service is responsible for sending its output to the next step.\nIt’s tempting to have each service evaluate the process-order flag after it’s processed and use this to decide the next step. However, if the flag is flipped in the middle of processing, this could cause problems.\nIf the flag is set to normalize-first, the batch starts at the normalization service. Before that service finishes processing, someone flips the flag to enable the relabel-first process. When the normalization service finishes processing, it’ll evaluate the process-order flag and use the relabel-first ordering, in which the normalization step is followed by storage. This data batch should be sent to the relabeling service because it hasn’t been relabeled, but it will be sent to storage instead.\nThis is an example of a situation in which flag consistency is required throughout multiple steps. The flag should be evaluated once for each batch, and that value should be sent in the call from service to service.\nConclusion In this guide, we covered:\nUsing code references to find feature flags in your codebase When and how to refactor to streamline your code How to improve code quality with flags 提高代码中特性标志使用的最佳实践\n阅读时间：10分钟 最后编辑：2024年9月18日 概览 本指南提供了最佳实践和建议，以改善使用特性标志的代码。这些实践可以提高代码质量和维护的便利性。\n您可以将代码与特性标志一起使用，以维护和提高您流程的弹性，包括改善标志卫生、为团队提供更多灵活性、在需要的程度上重构标志代码，以及普遍提高代码质量。\n并非所有最佳实践都适用于每个人\n本指南中提供的做法是主观的。对于一个团队来说可能是最佳实践，对于另一个团队可能效果不佳。在实施之前，请仔细考虑这些建议是否能帮助您的团队。\n概念 为了有效地使用本指南，您应该理解以下概念：\n提高标志卫生 项目中添加的大多数标志都是临时的，打算稍后移除。不幸的是，大多数团队在移除标志方面比添加标志更差，因为移除通常不那么紧迫。这可能导致代码库中充满了不再相关的标志。这在最好的情况下会使代码更难阅读；在最坏的情况下，不小心切换错误的标记可能会导致生产失败。\n使用标志的团队需要确保他们的代码只引用当前正在使用的标志。这种实践被称为“标志卫生”。以下是一些有助于维护良好标志卫生的技术。\n要了解更多关于标志卫生的信息，请阅读减少特性标志的技术债务 。\n扩展团队的“完成定义” 工程团队维护自己的标准，以确定何时可以认为任务或项目“完成”。例如，一个团队可能认为，除非代码有自动化测试，否则任务的代码不完整。\n您可以通过确保为任务或项目创建的临时标志不再被任何代码引用，并且在不再使用后被归档，来维护标志卫生。将此作为团队完成定义的要求，可能有助于简化您的代码库，因为只有您正在积极使用的标记才会出现在其中。\n通过持续集成（CI）系统执行的自动化检查，更容易维护代码标准。您甚至可以自动化一些标志卫生检查。\n使用代码引用跟踪标志卫生 LaunchDarkly的代码引用 功能跟踪您的代码中每个标志出现的位置。当您需要清理旧标志时，它特别有用。\n通过将 工具集成到您的代码管道中，确保您的项目的代码引用是最新的。\n要了解更多信息，请阅读代码引用 。\n这里是功能标志的代码引用部分的图片：\n功能标志的代码引用部分。\n重构标志代码以减少合并冲突 合并冲突是进行代码更改时常见的摩擦源。在函数中间添加标志逻辑会增加该添加及其后续删除与其他更改冲突的可能性。\n为了减少冲突的机会，重构标志逻辑和每个变体的代码到它们自己的函数中。保持重构简单，以便实现标志的总时间很短。\n下面的示例不使用真正的编程语言\n下面的示例使用近似于真实编程语言的示例来说明它们表达的概念。该语言基于JavaScript，但不是JavaScript。\n不要将这些代码示例用于生产环境。它们将无法工作。\n以下是一个演示这种分解策略的示例。示例代码来自一个虚构的应用程序，该应用程序具有查询后端搜索引擎的搜索功能。在现有代码中，函数getSearchResults负责将搜索查询发送到后端、检查错误并获取结果。\n以下是一个示例：\n伪代码\nfunction getSearchResults(query, context) { // 1. 解析查询以便引擎可以使用 // ...查询解析逻辑在这里... // 2. 将搜索查询发送到后端搜索引擎 engineURL = SEARCH_ENGINE_URL + '/search'; response = sendRequest(engineURL, parsedQuery); // 3. 检查错误 if (response.body.starts_with(\"SEARCH ERROR\")) { // 如果有错误，记录响应和上下文详细信息 log.ERROR(\"Search failure\", response, context); return new Error(\"There was an internal search error.\"); } else { // 4. 将响应转换为结果列表，清理结果等 // ...结果逻辑在这里... return results; } } 应用程序的工程团队正准备迁移到一个新的、改进的搜索引擎。为了准备迁移，团队创建了标志use-new-search-engine来告诉应用程序使用哪个搜索后端。代码需要包括查询旧搜索引擎和新搜索引擎的代码。\n在getSearchResults中间插入标志逻辑会使它比已经复杂的情况更加复杂。相反，他们提取相关代码并将其移动到新函数中。他们将发送查询到搜索引擎的代码（上述代码中的第2部分）以及处理错误和结果的代码（第3和第4部分），因为新引擎以不同的格式返回错误和结果。\n团队将这些代码行，以及新搜索引擎的代码和检查标志的代码，移动到它们自己的函数中：\n伪代码\n// 这个主函数的新版本更短， // 因为它将中心工作委托给executeSearch() function getSearchResults(query, context) { // 1. 解析查询以便引擎可以使用 // ...查询解析逻辑在这里... // 2. 将搜索查询发送到后端搜索引擎 response = executeSearch(parsedQuery, context); return response; } // 这个函数只检查“use-new-search-engine”标志的值 // 并将查询路由到下面的两个函数之一 // 执行实际的查询和处理 function executeSearch(query, context) { useNewEngine = ldclient.variation(\"use-new-search-engine\", context, false); if (useNewEngine == true) { return queryNewEngine(query, context); } else { return queryOldEngine(query, context); } } // 这个函数查询旧搜索引擎并处理响应 function queryOldEngine(query, context) { engineURL = SEARCH_ENGINE_URL + '/search'; response = sendRequest(engineURL, query); if (response.body.starts_with(\"SEARCH ERROR\")) { log.ERROR(\"Search failure on old engine\", response, context); return new Error(\"There was an internal search error.\"); } else { // 将响应转换为结果列表，清理结果等 // ...结果逻辑在这里... return results; } } // 这个函数查询新搜索引擎并处理响应 function queryNewEngine(query, context) { engineURL = NEW_SEARCH_ENGINE_URL + '/query'; response = sendRequest(engineURL, query); if (response.type == \"error\") { log.ERROR(\"Search failure on new engine\", response, context); return new Error(\"There was an internal search error.\"); } else { // 将新引擎响应转换为结果列表 // ...结果逻辑在这里... return results; } } 预计迁移将持续几周。由于新特性被包装在特性标志中，团队可以在新搜索引擎代码完全测试和优化之前集成它。现在，他们可以花时间使用真实生产数据改进代码。由于新旧搜索引擎代码被分离到不同的函数中，他们可以在不更改共享代码的情况下进行这些改进。此外，由于可以直接调用新代码而无需创建模拟标志状态，因此更容易为新代码添加单元测试。\n当需要退役旧搜索引擎并归档特性标志时，清理工作最少，不太可能引起合并冲突。\n清理步骤如下：\n删除executeSearch和queryOldEngine函数。 将queryNewEngine重命名为executeSearch。 在queryNewEngine中，将log.ERROR消息从\"Search failure on new engine\"更改为仅\"Search failure\"，因为现在只有一个引擎了。 避免额外的重构 queryOldEngine 和 queryNewEngine 都包含类似的代码。这个示例的另一个版本甚至可能包含更多在两个函数之间重复的代码行。您可能想要通过将重复的代码移动到一个共享函数中来进一步重构。\n有几个原因不进行代码去重。\n代码并非为长期维护而设计。迁移完成后，重复的代码将被删除。 在您改进 queryNewEngine 时，可能会有短期的维护工作。过早的重构可能会比帮助更多地阻碍维护。 我们推荐一个常见的重构格言，称为《三的法则》 ：在代码重复三次或更多次之前，不要为了去重而进行重构。\n提高代码质量 在代码中添加特性标志增加了其灵活性，但也可能增加复杂性。代码越复杂，诊断和纠正意外问题就越困难。\n您可以使用各种技术来确保特性标志帮助您实现代码的目标。\n以下是一些您可以遵循的指导方针，以确保您编写高质量的代码：\n避免在调用接口中传递标志状态 当您使用特性标志来改变组件的行为时，请在组件内部执行标志评估。\n可能很想在调用接口中添加一个专用参数，并从外部发送标志状态。然而，改变组件的接口意味着所有调用该组件的代码也必须改变，一旦标志被移除，又需要再次改变。\n考虑我们之前用作示例的 executeSearch 函数。它调用 ldclient.variation 在其自己的实现内部评估标志。\n如果我们将那个调用移到 getSearchResults 并将标志值作为参数传递给 executeSearch，简化后的代码将如下所示：\n伪代码\nfunction getSearchResults(query, context) { // 1. 解析查询以便引擎可以使用 // ...查询解析逻辑在这里... // 2. 将搜索查询发送到后端搜索引擎 // 带有特性标志值 useNewEngine = ldclient.variation(\"use-new-search-engine\", context, false); response = executeSearch(parsedQuery, context, useNewEngine); return response; } // `useNewEngine` 现在在调用中提供 function executeSearch(query, context, useNewEngine) { if (useNewEngine == true) { return queryNewEngine(query, context); } else { return queryOldEngine(query, context); } } 我们以标志为导向的重构目的是为了通过分离出需要改变的代码，并将其包含在专用函数中，来减少合并冲突。不幸的是，在 getSearchResults 中放入标志评估代码，给它带来了它不需要的更多责任，并消除了重构的好处。\n在这个例子中，改变的接口只有一个调用者。当改变有多个调用者的函数和模块时，保持接口不变的好处更大。鉴于改变频繁使用的代码的其他风险，这一点尤其重要。\n标志可以随时改变 您的代码执行得越频繁，当一个关键标志被改变时，您的代码在执行中途的可能性就越大。如果您的代码构建方式期望标志状态在代码路径的开始和结束之间保持一致，它可能会导致特别难以调试的问题。\n避免这个问题的一种方法是使用 LaunchDarkly 的自定义角色功能来限制谁可以访问该标志。\n要了解更多信息，请阅读自定义角色 。\n这可能会使改变标志变得更加困难，在某些情况下可能是好事，但它也增加了您开发过程中的摩擦。与其使改变更加困难，不如提高代码的健壮性。\n以下示例使用一个服务，该服务将批量数据通过处理管道发送。每个批次必须经过三个处理步骤：规范化、重新标记和存储。\n一个专用服务执行这些步骤中的每一个。存储步骤始终是最后一个，但规范化和重新标记可以以任何顺序发生。每个服务负责将数据批次发送到下一个服务。\n有两种可能的顺序可以执行处理步骤。顺序是使用一个名为 process-order 的特性标志选择的，该标志有 normalize-first 和 relabel-first 两种变化。\nnormalize-first 顺序是：\n规范化 重新标记 存储 relabel-first 顺序如下：\n重新标记 规范化 存储 每个服务负责将其输出发送到下一步。\n在每个服务处理后评估 process-order 标志并使用此来决定下一步是很诱人的。然而，如果在处理中途标志被翻转，这可能会导致问题。\n如果标志被设置为 normalize-first，则批次从规范化服务开始。在该服务完成处理之前，有人翻转了标志以启用 relabel-first 过程。当规范化服务完成处理时，它将评估 process-order 标志并使用 relabel-first 顺序，在该顺序中，规范化步骤后跟存储。这个数据批次应该被发送到重新标记服务，因为它还没有被重新标记，但它将被发送到存储服务。\n这是一个需要在整个多个步骤中保持标志一致性的情况示例。标志应该为每个批次评估一次，并且该值应该在服务之间的调用中发送。\n结论 在本指南中，我们涵盖了：\n使用代码引用在您的代码库中找到特性标志 何时以及如何重构以简化您的代码 如何通过标志提高代码质量 ","wordCount":"6129","inLanguage":"en","datePublished":"2024-10-20T00:00:00Z","dateModified":"2024-10-20T00:00:00Z","author":{"@type":"Person","name":"Joey"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://joeyzheng.tech/posts/improving-flag-usage-in-code/"},"publisher":{"@type":"Organization","name":"黄庄以北","logo":{"@type":"ImageObject","url":"https://joeyzheng.tech/favicon.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://joeyzheng.tech/ accesskey=h title="黄庄以北 (Alt + H)">黄庄以北</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://joeyzheng.tech/categories/ title=categories><span>categories</span></a></li><li><a href=https://joeyzheng.tech/tags/ title=tags><span>tags</span></a></li><li><a href=https://joeyzheng.tech/ title=joeyzheng.tech><span>joeyzheng.tech</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://joeyzheng.tech/>Home</a>&nbsp;»&nbsp;<a href=https://joeyzheng.tech/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Improving flag usage in code</h1><div class=post-meta><span title='2024-10-20 00:00:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;6129 words&nbsp;·&nbsp;Joey</div></header><div class=post-content><h1 id=improving-flag-usage-in-code>Improving flag usage in code<a hidden class=anchor aria-hidden=true href=#improving-flag-usage-in-code>#</a></h1><h5 id=read-time10minutes>Read time: 10 minutes<a hidden class=anchor aria-hidden=true href=#read-time10minutes>#</a></h5><h5 id=last-editedsep-18-2024>Last edited: Sep 18, 2024<a hidden class=anchor aria-hidden=true href=#last-editedsep-18-2024>#</a></h5><h2 id=httpsdocslaunchdarklycomguidesflagsimproving-codeoverviewoverview><a href=https://docs.launchdarkly.com/guides/flags/improving-code#overview target=_blank rel="noopener noreferrer nofollow"></a>Overview</h2><p>This guide provides best practices and suggestions for improving code that uses feature flags. These practices can improve both code quality and ease of maintenance.</p><p>You can use code in tandem with your feature flags to maintain and improve the resilience of your process, including improving flag hygiene, giving your team more flexibility, refactoring flagged code to the degree that you need and no further, and generally increasing code quality.</p><p>Not all best practices work for everyone</p><p>The practices we offer in this guide are subjective. What may be a best practice for one team may not work as well for another. Review the recommendations in this guide and consider carefully if they will help your team before you implement them.</p><h2 id=httpsdocslaunchdarklycomguidesflagsimproving-codeconceptsconcepts><a href=https://docs.launchdarkly.com/guides/flags/improving-code#concepts target=_blank rel="noopener noreferrer nofollow"></a>Concepts</h2><p>In order to use this guide effectively, you should understand these concepts:</p><h3 id=httpsdocslaunchdarklycomguidesflagsimproving-codeimprove-flag-hygieneimprove-flag-hygiene><a href=https://docs.launchdarkly.com/guides/flags/improving-code#improve-flag-hygiene target=_blank rel="noopener noreferrer nofollow"></a>Improve flag hygiene</h3><p>Most of the flags added to a project are temporary, intended to be removed later. Unfortunately, most teams are worse at removing flags than adding them, because removal is usually less urgent. This can lead to a codebase cluttered with flags that are no longer relevant. At best, this makes the code harder to read; at worst, inadvertently toggling the wrong flag can cause production failures.</p><p>Teams that use flags need to ensure that their code only references flags which are currently in use. This practice is known as &ldquo;flag hygiene.&rdquo; Here is a selection of techniques that help maintain good flag hygiene.</p><p>To learn more about flag hygiene, read <a href=https://docs.launchdarkly.com/guides/flags/technical-debt target=_blank rel="noopener noreferrer nofollow">Reducing technical debt from feature flags</a>
.</p><h3 id=httpsdocslaunchdarklycomguidesflagsimproving-codeextend-your-teams-definition-of-doneextend-your-teams-definition-of-done><a href=https://docs.launchdarkly.com/guides/flags/improving-code#extend-your-teams-definition-of-done target=_blank rel="noopener noreferrer nofollow"></a>Extend your team&rsquo;s &ldquo;definition of done&rdquo;</h3><p>Engineering teams maintain their own standards for when a task or project can be considered &ldquo;done.&rdquo; For example, a team may consider the code for a task to be incomplete until it has automated tests.</p><p>You can maintain flag hygiene by ensuring that the temporary flags created for a task or project are no longer referenced by any code and are archived after they&rsquo;re no longer in use. Adding this as a requirement to your team&rsquo;s definition of done may help streamline your codebase, because only the flags you&rsquo;re actively using will be present in it.</p><p>Code standards are easier to maintain with automated checks, such as those performed by a continuous integration (CI) system. You can even automate some flag hygiene checks.</p><h2 id=httpsdocslaunchdarklycomguidesflagsimproving-codeuse-code-references-to-track-flag-hygieneuse-code-references-to-track-flag-hygiene><a href=https://docs.launchdarkly.com/guides/flags/improving-code#use-code-references-to-track-flag-hygiene target=_blank rel="noopener noreferrer nofollow"></a>Use code references to track flag hygiene</h2><p>LaunchDarkly&rsquo;s <a href=https://docs.launchdarkly.com/home/observability/code-references target=_blank rel="noopener noreferrer nofollow">code references</a>
 feature keeps track of the places in your code where each flag appears. It&rsquo;s particularly useful when you need to clean up old flags.</p><p>Ensure that the code references for your project are up to date by integrating the <a href=https://github.com/launchdarkly/ld-find-code-refs/ target=_blank rel="noopener noreferrer nofollow">&lt;code>ld-find-code-refs&lt;/code></a>
 tool with your code pipeline.</p><p>To learn more, read <a href=https://docs.launchdarkly.com/home/observability/code-references target=_blank rel="noopener noreferrer nofollow">Code references</a>
.</p><p>Here is an image of the code references section for a feature flag:</p><p><img loading=lazy src=https://img.joeyzheng.tech/ob-1729145718689.png></p><p>The code references section of a feature flag.</p><h2 id=httpsdocslaunchdarklycomguidesflagsimproving-coderefactor-flagged-code-to-reduce-merge-conflictsrefactor-flagged-code-to-reduce-merge-conflicts><a href=https://docs.launchdarkly.com/guides/flags/improving-code#refactor-flagged-code-to-reduce-merge-conflicts target=_blank rel="noopener noreferrer nofollow"></a>Refactor flagged code to reduce merge conflicts</h2><p>Merge conflicts are a common source of friction when you make code changes. Adding flag logic in the middle of a function increases the chances that both that addition and its removal later will conflict with other changes.</p><p>To reduce the chance of conflicts, refactor both the flag logic and the code for each variation into their own functions. Keep the refactoring simple so that the overall time spent implementing the flag is short.</p><p>The examples below do not use a real coding language</p><p>The examples below use an approximation of a real coding language to illustrate the concepts they express. The language is based on JavaScript, but is not JavaScript.</p><p>Do not use these code samples in a production environment. They will not work.</p><p>Here&rsquo;s an example to demonstrate this factoring tactic. The example code is taken from a fictional app which has a search feature which queries a back-end search engine. In the existing code, the function <code>getSearchResults</code> does the work of sending the search query to the backend, checking for errors and fetching the results.</p><p>Here is an example:</p><p>pseudocode</p><p>function getSearchResults(query, context) {</p><p>// 1. parse the query so engine can use it</p><p>// &mldr; query parsing logic goes here&mldr;</p><p>// 2. send the search query to the back-end search engine</p><p>engineURL = SEARCH_ENGINE_URL + &lsquo;/search&rsquo;;</p><p>response = sendRequest(engineURL, parsedQuery);</p><p>// 3. check for errors</p><p>if (response.body.starts_with(&ldquo;SEARCH ERROR&rdquo;)) {</p><pre><code>// if there's an error, log the response and context details

log.ERROR(&quot;Search failure&quot;, response, context);

return new Error(&quot;There was an internal search error.&quot;);
</code></pre><p>} else {</p><pre><code>// 4. turn response into a result list, clean up the results, etc.

// ... results logic goes here...

return results;
</code></pre><p>}</p><p>}</p><p>COPY</p><p>The app&rsquo;s engineering team is preparing to migrate to a new, improved search engine. To prepare for the migration, the team has created the flag <code>use-new-search-engine</code> to tell the app which search back-end to use. The code needs to include code for querying both the old and the new search engines.</p><p>Inserting the flag logic in the middle of <code>getSearchResults</code> would make it even more complicated than it is already. Instead, they extract the relevant code and move it to new functions. They take the code which sends the query to the search engine (section 2 in the code above) and also code which processes errors and results (sections 3 and 4), because the new engine returns errors and results in a different format.</p><p>The team moves these lines of code, along with code for the new search engine and code to check the flag, into their own functions:</p><p>pseudocode</p><p>// This new version of the main function is much shorter,</p><p>// because it delegates the central work to executeSearch()</p><p>function getSearchResults(query, context) {</p><p>// 1. parse the query so engine can use it</p><p>// &mldr; query parsing logic goes here&mldr;</p><p>// 2. send the search query to the back-end search engine</p><p>response = executeSearch(parsedQuery, context);</p><p>return response;</p><p>}</p><p>// This function only checks the value of the &ldquo;use-new-search-engine&rdquo; flag</p><p>// and routes the query to one of the two functions below</p><p>// to do the actual querying and processing</p><p>function executeSearch(query, context) {</p><p>useNewEngine = ldclient.variation(&ldquo;use-new-search-engine&rdquo;, context, false);</p><p>if (useNewEngine == true) {</p><pre><code>return queryNewEngine(query, context);
</code></pre><p>} else {</p><pre><code>return queryOldEngine(query, context);
</code></pre><p>}</p><p>}</p><p>// This function queries the OLD search engine and processes the response</p><p>function queryOldEngine(query, context) {</p><p>engineURL = SEARCH_ENGINE_URL + &lsquo;/search&rsquo;;</p><p>response = sendRequest(engineURL, query);</p><p>if (response.body.starts_with(&ldquo;SEARCH ERROR&rdquo;)) {</p><pre><code>log.ERROR(&quot;Search failure on old engine&quot;, response, context);

return new Error(&quot;There was an internal search error.&quot;);
</code></pre><p>} else {</p><pre><code>// turn response into result list, clean up the results, etc.

// ... results logic goes here...

return results;
</code></pre><p>}</p><p>}</p><p>// This function queries the NEW search engine and processes the response</p><p>function queryNewEngine(query, context) {</p><p>engineURL = NEW_SEARCH_ENGINE_URL + &lsquo;/query&rsquo;;</p><p>response = sendRequest(engineURL, query);</p><p>if (response.type == &ldquo;error&rdquo;) {</p><pre><code>log.ERROR(&quot;Search failure on new engine&quot;, response, context);

return new Error(&quot;There was an internal search error.&quot;);
</code></pre><p>} else {</p><pre><code>// turn new-engine response into a result list

// ... results logic goes here...

return results;
</code></pre><p>}</p><p>}</p><p>COPY</p><p>The migration is expected to last a few weeks. Because the new feature is wrapped in a feature flag, the team can integrate the new search engine code before it&rsquo;s been fully tested and optimized. Now, they can spend time improving the code with real production data. Because the new and old search engine code is separated into different functions, they can make those improvements without changing shared code. In addition, it&rsquo;s easier to add unit tests for the new code because they can call it directly without needing to create mock flag states.</p><p>When it&rsquo;s time to retire the old search engine and archive the feature flag, the cleanup is minimal and less likely to cause merge conflicts.</p><p>The cleanup steps are:</p><ol><li>Delete the <code>executeSearch</code> and <code>queryOldEngine</code> functions.</li><li>Rename <code>queryNewEngine</code> to <code>executeSearch</code>.</li><li>Within <code>queryNewEngine</code>, change the <code>log.ERROR</code> message from <code>"Search failure on new engine"</code> to just <code>"Search failure"</code>, because there is only one engine now.</li></ol><h3 id=httpsdocslaunchdarklycomguidesflagsimproving-codeavoid-additional-refactoringavoid-additional-refactoring><a href=https://docs.launchdarkly.com/guides/flags/improving-code#avoid-additional-refactoring target=_blank rel="noopener noreferrer nofollow"></a>Avoid additional refactoring</h3><p>Both <code>queryOldEngine</code> and <code>queryNewEngine</code> contain similar code. Another version of this example could even contain more lines of code which are duplicated between both functions. You might want to refactor further by moving the duplicated code into a shared function.</p><p>There are a couple of reasons not to deduplicate code.</p><ul><li>The code is not intended for long-term maintenance. After the migration is finished, the duplicates are deleted.</li><li>There is likely to be <em>short-term</em> maintenance as you improve <code>queryNewEngine</code>. Premature refactoring may hinder that maintenance more than it helps.</li></ul><p>We recommend the common refactoring adage known as <a href=https://en.wikipedia.org/wiki/Rule_of_three_%28computer_programming%29 target=_blank rel="noopener noreferrer nofollow">&lt;em>the rule of three&lt;/em></a>
: don&rsquo;t refactor for deduplication until code is duplicated three or more times.</p><h2 id=httpsdocslaunchdarklycomguidesflagsimproving-codeimprove-code-qualityimprove-code-quality><a href=https://docs.launchdarkly.com/guides/flags/improving-code#improve-code-quality target=_blank rel="noopener noreferrer nofollow"></a>Improve code quality</h2><p>Adding feature flags to code increases its flexibility, but can also add complexity. The more complex your code is, the more difficult it is to diagnose and correct an unexpected problem.</p><p>There are various techniques you can use to make sure that your feature flags help accomplish what you want to do with code.</p><p>Here are some guidelines you can follow to make sure you write high-quality code:</p><h3 id=httpsdocslaunchdarklycomguidesflagsimproving-codeavoid-passing-flag-state-in-a-call-interfaceavoid-passing-flag-state-in-a-call-interface><a href=https://docs.launchdarkly.com/guides/flags/improving-code#avoid-passing-flag-state-in-a-call-interface target=_blank rel="noopener noreferrer nofollow"></a>Avoid passing flag state in a call interface</h3><p>When you use a feature flag to change the behavior of a component, perform the flag evaluation <em>inside</em> the component.</p><p>It can be tempting to add a dedicated parameter to the call interface and send the flag state from the outside. However, changing the component&rsquo;s interface means that all the component&rsquo;s callers have to be changed too, and then changed again once the flag is removed.</p><p>Consider the <code>executeSearch</code> function we used as an example earlier. It calls <code>ldclient.variation</code> to evaluate the flag from within its own implementation.</p><p>If we moved that call out to <code>getSearchResults</code> and sent the flag value to <code>executeSearch</code> as an argument, the abbreviated code would look like this:</p><p>pseudocode</p><p>function getSearchResults(query, context) {</p><p>// 1. parse the query so engine can use it</p><p>// &mldr; query parsing logic goes here&mldr;</p><p>// 2. send the search query to the back-end search engine</p><p>// with the feature flag value</p><p>useNewEngine = ldclient.variation(&ldquo;use-new-search-engine&rdquo;, context, false);</p><p>response = executeSearch(parsedQuery, context, useNewEngine);</p><p>return response;</p><p>}</p><p>// <code>useNewEngine</code> is now supplied in the call</p><p>function executeSearch(query, context, useNewEngine) {</p><p>if (useNewEngine == true) {</p><pre><code>return queryNewEngine(query, context);
</code></pre><p>} else {</p><pre><code>return queryOldEngine(query, context);
</code></pre><p>}</p><p>}</p><p>COPY</p><p>The purpose of our flag-oriented refactoring was to reduce merge conflicts by separating out the code that would need to change, and keeping it contained in dedicated functions. Unfortunately, putting the flag evaluation code in <code>getSearchResults</code> has given it more responsibility that it didn&rsquo;t need, and removed the benefits of the refactoring.</p><p>In this example, the changed interface only had one caller. When changing functions and modules with many callers, there&rsquo;s even greater benefit in keeping the interface the same. This is especially important given the other risks inherent in changing heavily-used code.</p><h3 id=httpsdocslaunchdarklycomguidesflagsimproving-codeflags-can-change-any-timeflags-can-change-any-time><a href=https://docs.launchdarkly.com/guides/flags/improving-code#flags-can-change-any-time target=_blank rel="noopener noreferrer nofollow"></a>Flags can change any time</h3><p>The more frequently that your code is executed, the more likely it is that your code will be in the middle of executing when a vital flag is changed. If your code is constructed in a way that expects flag state to stay consistent between the start and end of a code path, it can cause problems that are particularly hard to debug.</p><p>One way to avoid this problem is to use LaunchDarkly&rsquo;s custom roles feature to restrict who can access the flag.</p><p>To learn more, read <a href=https://docs.launchdarkly.com/home/account/custom-roles target=_blank rel="noopener noreferrer nofollow">Custom roles</a>
.</p><p>This can make it harder to change a flag, which can be good in some cases, but it also increases the friction in your development process. Instead of making change more difficult, it&rsquo;s better to improve the robustness of your code.</p><p>The following example uses a service that sends batches of data through a processing pipeline. Each batch must go through three processing steps: normalization, relabeling, and storage.</p><p>A dedicated service performs each of these steps. The storage step is always the last, but the normalization and relabeling can happen in either order. Each service is responsible for sending the data batch to the next service.</p><p>There are two possible orders in which the processing steps can be performed. The order is chosen using a feature flag called <code>process-order</code> which has variations <code>normalize-first</code> and <code>relabel-first</code>.</p><p>The <code>normalize-first</code> order is:</p><ol><li>Normalization</li><li>Relabeling</li><li>Storage</li></ol><p>The <code>relabel-first</code> order looks like this:</p><ol><li>Relabeling</li><li>Normalization</li><li>Storage</li></ol><p>Each service is responsible for sending its output to the next step.</p><p>It&rsquo;s tempting to have each service evaluate the <code>process-order</code> flag after it&rsquo;s processed and use this to decide the next step. However, if the flag is flipped in the middle of processing, this could cause problems.</p><p>If the flag is set to <code>normalize-first</code>, the batch starts at the normalization service. Before that service finishes processing, someone flips the flag to enable the <code>relabel-first</code> process. When the normalization service finishes processing, it&rsquo;ll evaluate the <code>process-order</code> flag and use the <code>relabel-first</code> ordering, in which the normalization step is followed by storage. This data batch should be sent to the relabeling service because it hasn&rsquo;t been relabeled, but it will be sent to storage instead.</p><p>This is an example of a situation in which flag consistency is required throughout multiple steps. The flag should be evaluated once for each batch, and that value should be sent in the call from service to service.</p><h2 id=httpsdocslaunchdarklycomguidesflagsimproving-codeconclusionconclusion><a href=https://docs.launchdarkly.com/guides/flags/improving-code#conclusion target=_blank rel="noopener noreferrer nofollow"></a>Conclusion</h2><p>In this guide, we covered:</p><ul><li>Using code references to find feature flags in your codebase</li><li>When and how to refactor to streamline your code</li><li>How to improve code quality with flags</li></ul><p>提高代码中特性标志使用的最佳实践</p><h4 id=阅读时间10分钟>阅读时间：10分钟<a hidden class=anchor aria-hidden=true href=#阅读时间10分钟>#</a></h4><h4 id=最后编辑2024年9月18日>最后编辑：2024年9月18日<a hidden class=anchor aria-hidden=true href=#最后编辑2024年9月18日>#</a></h4><h2 id=httpsundefined概览><a href=https://undefined/ target=_blank rel="noopener noreferrer nofollow"></a>概览</h2><p>本指南提供了最佳实践和建议，以改善使用特性标志的代码。这些实践可以提高代码质量和维护的便利性。</p><p>您可以将代码与特性标志一起使用，以维护和提高您流程的弹性，包括改善标志卫生、为团队提供更多灵活性、在需要的程度上重构标志代码，以及普遍提高代码质量。</p><p>并非所有最佳实践都适用于每个人</p><p>本指南中提供的做法是主观的。对于一个团队来说可能是最佳实践，对于另一个团队可能效果不佳。在实施之前，请仔细考虑这些建议是否能帮助您的团队。</p><h2 id=httpsundefined概念><a href=https://undefined/ target=_blank rel="noopener noreferrer nofollow"></a>概念</h2><p>为了有效地使用本指南，您应该理解以下概念：</p><h3 id=httpsundefined提高标志卫生><a href=https://undefined/ target=_blank rel="noopener noreferrer nofollow"></a>提高标志卫生</h3><p>项目中添加的大多数标志都是临时的，打算稍后移除。不幸的是，大多数团队在移除标志方面比添加标志更差，因为移除通常不那么紧迫。这可能导致代码库中充满了不再相关的标志。这在最好的情况下会使代码更难阅读；在最坏的情况下，不小心切换错误的标记可能会导致生产失败。</p><p>使用标志的团队需要确保他们的代码只引用当前正在使用的标志。这种实践被称为“标志卫生”。以下是一些有助于维护良好标志卫生的技术。</p><p>要了解更多关于标志卫生的信息，请阅读<a href=https://docs.launchdarkly.com/guides/flags/technical-debt target=_blank rel="noopener noreferrer nofollow">减少特性标志的技术债务</a>
。</p><h3 id=httpsundefined扩展团队的完成定义><a href=https://undefined/ target=_blank rel="noopener noreferrer nofollow"></a>扩展团队的“完成定义”</h3><p>工程团队维护自己的标准，以确定何时可以认为任务或项目“完成”。例如，一个团队可能认为，除非代码有自动化测试，否则任务的代码不完整。</p><p>您可以通过确保为任务或项目创建的临时标志不再被任何代码引用，并且在不再使用后被归档，来维护标志卫生。将此作为团队完成定义的要求，可能有助于简化您的代码库，因为只有您正在积极使用的标记才会出现在其中。</p><p>通过持续集成（CI）系统执行的自动化检查，更容易维护代码标准。您甚至可以自动化一些标志卫生检查。</p><h2 id=httpsundefined使用代码引用跟踪标志卫生><a href=https://undefined/ target=_blank rel="noopener noreferrer nofollow"></a>使用代码引用跟踪标志卫生</h2><p>LaunchDarkly的<a href=https://docs.launchdarkly.com/home/observability/code-references target=_blank rel="noopener noreferrer nofollow">代码引用</a>
功能跟踪您的代码中每个标志出现的位置。当您需要清理旧标志时，它特别有用。</p><p>通过将<a href=https://undefined/ target=_blank rel="noopener noreferrer nofollow"></a>
工具集成到您的代码管道中，确保您的项目的代码引用是最新的。</p><p>要了解更多信息，请阅读<a href=https://docs.launchdarkly.com/home/observability/code-references target=_blank rel="noopener noreferrer nofollow">代码引用</a>
。</p><p>这里是功能标志的代码引用部分的图片：</p><p><a href=https://undefined/ target=_blank rel="noopener noreferrer nofollow"></a></p><p>功能标志的代码引用部分。</p><h2 id=httpsundefined重构标志代码以减少合并冲突><a href=https://undefined/ target=_blank rel="noopener noreferrer nofollow"></a>重构标志代码以减少合并冲突</h2><p>合并冲突是进行代码更改时常见的摩擦源。在函数中间添加标志逻辑会增加该添加及其后续删除与其他更改冲突的可能性。</p><p>为了减少冲突的机会，重构标志逻辑和每个变体的代码到它们自己的函数中。保持重构简单，以便实现标志的总时间很短。</p><p>下面的示例不使用真正的编程语言</p><p>下面的示例使用近似于真实编程语言的示例来说明它们表达的概念。该语言基于JavaScript，但不是JavaScript。</p><p>不要将这些代码示例用于生产环境。它们将无法工作。</p><p>以下是一个演示这种分解策略的示例。示例代码来自一个虚构的应用程序，该应用程序具有查询后端搜索引擎的搜索功能。在现有代码中，函数<code>getSearchResults</code>负责将搜索查询发送到后端、检查错误并获取结果。</p><p>以下是一个示例：</p><p>伪代码</p><pre tabindex=0><code>function getSearchResults(query, context) {

  // 1. 解析查询以便引擎可以使用

  // ...查询解析逻辑在这里...

  // 2. 将搜索查询发送到后端搜索引擎

  engineURL = SEARCH_ENGINE_URL + &#39;/search&#39;;

  response = sendRequest(engineURL, parsedQuery);

  // 3. 检查错误

  if (response.body.starts_with(&#34;SEARCH ERROR&#34;)) {

    // 如果有错误，记录响应和上下文详细信息

    log.ERROR(&#34;Search failure&#34;, response, context);

    return new Error(&#34;There was an internal search error.&#34;);

  } else {

    // 4. 将响应转换为结果列表，清理结果等

    // ...结果逻辑在这里...

    return results;

  }

}
</code></pre><p>应用程序的工程团队正准备迁移到一个新的、改进的搜索引擎。为了准备迁移，团队创建了标志<code>use-new-search-engine</code>来告诉应用程序使用哪个搜索后端。代码需要包括查询旧搜索引擎和新搜索引擎的代码。</p><p>在<code>getSearchResults</code>中间插入标志逻辑会使它比已经复杂的情况更加复杂。相反，他们提取相关代码并将其移动到新函数中。他们将发送查询到搜索引擎的代码（上述代码中的第2部分）以及处理错误和结果的代码（第3和第4部分），因为新引擎以不同的格式返回错误和结果。</p><p>团队将这些代码行，以及新搜索引擎的代码和检查标志的代码，移动到它们自己的函数中：</p><p>伪代码</p><pre tabindex=0><code>// 这个主函数的新版本更短，

// 因为它将中心工作委托给executeSearch()

function getSearchResults(query, context) {

  // 1. 解析查询以便引擎可以使用

  // ...查询解析逻辑在这里...

  // 2. 将搜索查询发送到后端搜索引擎

  response = executeSearch(parsedQuery, context);

  return response;

}

// 这个函数只检查“use-new-search-engine”标志的值

// 并将查询路由到下面的两个函数之一

// 执行实际的查询和处理

function executeSearch(query, context) {

  useNewEngine = ldclient.variation(&#34;use-new-search-engine&#34;, context, false);

  if (useNewEngine == true) {

    return queryNewEngine(query, context);

  } else {

    return queryOldEngine(query, context);

  }

}

// 这个函数查询旧搜索引擎并处理响应

function queryOldEngine(query, context) {

  engineURL = SEARCH_ENGINE_URL + &#39;/search&#39;;

  response = sendRequest(engineURL, query);

  if (response.body.starts_with(&#34;SEARCH ERROR&#34;)) {

    log.ERROR(&#34;Search failure on old engine&#34;, response, context);

    return new Error(&#34;There was an internal search error.&#34;);

  } else {

    // 将响应转换为结果列表，清理结果等

    // ...结果逻辑在这里...

    return results;

  }

}

// 这个函数查询新搜索引擎并处理响应

function queryNewEngine(query, context) {

  engineURL = NEW_SEARCH_ENGINE_URL + &#39;/query&#39;;

  response = sendRequest(engineURL, query);

  if (response.type == &#34;error&#34;) {

    log.ERROR(&#34;Search failure on new engine&#34;, response, context);

    return new Error(&#34;There was an internal search error.&#34;);

  } else {

    // 将新引擎响应转换为结果列表

    // ...结果逻辑在这里...

    return results;

  }

}
</code></pre><p>预计迁移将持续几周。由于新特性被包装在特性标志中，团队可以在新搜索引擎代码完全测试和优化之前集成它。现在，他们可以花时间使用真实生产数据改进代码。由于新旧搜索引擎代码被分离到不同的函数中，他们可以在不更改共享代码的情况下进行这些改进。此外，由于可以直接调用新代码而无需创建模拟标志状态，因此更容易为新代码添加单元测试。</p><p>当需要退役旧搜索引擎并归档特性标志时，清理工作最少，不太可能引起合并冲突。</p><p>清理步骤如下：</p><ol><li>删除<code>executeSearch</code>和<code>queryOldEngine</code>函数。</li><li>将<code>queryNewEngine</code>重命名为<code>executeSearch</code>。</li><li>在<code>queryNewEngine</code>中，将<code>log.ERROR</code>消息从<code>"Search failure on new engine"</code>更改为仅<code>"Search failure"</code>，因为现在只有一个引擎了。</li></ol><h3 id=避免额外的重构>避免额外的重构<a hidden class=anchor aria-hidden=true href=#避免额外的重构>#</a></h3><p><code>queryOldEngine</code> 和 <code>queryNewEngine</code> 都包含类似的代码。这个示例的另一个版本甚至可能包含更多在两个函数之间重复的代码行。您可能想要通过将重复的代码移动到一个共享函数中来进一步重构。</p><p>有几个原因不进行代码去重。</p><ul><li>代码并非为长期维护而设计。迁移完成后，重复的代码将被删除。</li><li>在您改进 <code>queryNewEngine</code> 时，可能会有短期的维护工作。过早的重构可能会比帮助更多地阻碍维护。</li></ul><p>我们推荐一个常见的重构格言，称为<a href=https://en.wikipedia.org/wiki/Rule_of_three_%28computer_programming%29 target=_blank rel="noopener noreferrer nofollow">《三的法则》</a>
：在代码重复三次或更多次之前，不要为了去重而进行重构。</p><h2 id=提高代码质量>提高代码质量<a hidden class=anchor aria-hidden=true href=#提高代码质量>#</a></h2><p>在代码中添加特性标志增加了其灵活性，但也可能增加复杂性。代码越复杂，诊断和纠正意外问题就越困难。</p><p>您可以使用各种技术来确保特性标志帮助您实现代码的目标。</p><p>以下是一些您可以遵循的指导方针，以确保您编写高质量的代码：</p><h3 id=避免在调用接口中传递标志状态>避免在调用接口中传递标志状态<a hidden class=anchor aria-hidden=true href=#避免在调用接口中传递标志状态>#</a></h3><p>当您使用特性标志来改变组件的行为时，请在组件<strong>内部</strong>执行标志评估。</p><p>可能很想在调用接口中添加一个专用参数，并从外部发送标志状态。然而，改变组件的接口意味着所有调用该组件的代码也必须改变，一旦标志被移除，又需要再次改变。</p><p>考虑我们之前用作示例的 <code>executeSearch</code> 函数。它调用 <code>ldclient.variation</code> 在其自己的实现内部评估标志。</p><p>如果我们将那个调用移到 <code>getSearchResults</code> 并将标志值作为参数传递给 <code>executeSearch</code>，简化后的代码将如下所示：</p><p>伪代码</p><pre tabindex=0><code>function getSearchResults(query, context) {
  // 1. 解析查询以便引擎可以使用

  // ...查询解析逻辑在这里...

  // 2. 将搜索查询发送到后端搜索引擎

  //    带有特性标志值

  useNewEngine = ldclient.variation(&#34;use-new-search-engine&#34;, context, false);

  response = executeSearch(parsedQuery, context, useNewEngine);

  return response;
}

// `useNewEngine` 现在在调用中提供

function executeSearch(query, context, useNewEngine) {
  if (useNewEngine == true) {
    return queryNewEngine(query, context);
  } else {
    return queryOldEngine(query, context);
  }
}
</code></pre><p>我们以标志为导向的重构目的是为了通过分离出需要改变的代码，并将其包含在专用函数中，来减少合并冲突。不幸的是，在 <code>getSearchResults</code> 中放入标志评估代码，给它带来了它不需要的更多责任，并消除了重构的好处。</p><p>在这个例子中，改变的接口只有一个调用者。当改变有多个调用者的函数和模块时，保持接口不变的好处更大。鉴于改变频繁使用的代码的其他风险，这一点尤其重要。</p><h3 id=标志可以随时改变>标志可以随时改变<a hidden class=anchor aria-hidden=true href=#标志可以随时改变>#</a></h3><p>您的代码执行得越频繁，当一个关键标志被改变时，您的代码在执行中途的可能性就越大。如果您的代码构建方式期望标志状态在代码路径的开始和结束之间保持一致，它可能会导致特别难以调试的问题。</p><p>避免这个问题的一种方法是使用 LaunchDarkly 的自定义角色功能来限制谁可以访问该标志。</p><p>要了解更多信息，请阅读<a href=https://docs.launchdarkly.com/home/account/custom-roles target=_blank rel="noopener noreferrer nofollow">自定义角色</a>
。</p><p>这可能会使改变标志变得更加困难，在某些情况下可能是好事，但它也增加了您开发过程中的摩擦。与其使改变更加困难，不如提高代码的健壮性。</p><p>以下示例使用一个服务，该服务将批量数据通过处理管道发送。每个批次必须经过三个处理步骤：规范化、重新标记和存储。</p><p>一个专用服务执行这些步骤中的每一个。存储步骤始终是最后一个，但规范化和重新标记可以以任何顺序发生。每个服务负责将数据批次发送到下一个服务。</p><p>有两种可能的顺序可以执行处理步骤。顺序是使用一个名为 <code>process-order</code> 的特性标志选择的，该标志有 <code>normalize-first</code> 和 <code>relabel-first</code> 两种变化。</p><p><code>normalize-first</code> 顺序是：</p><ol><li>规范化</li><li>重新标记</li><li>存储</li></ol><p><code>relabel-first</code> 顺序如下：</p><ol><li>重新标记</li><li>规范化</li><li>存储</li></ol><p>每个服务负责将其输出发送到下一步。</p><p>在每个服务处理后评估 <code>process-order</code> 标志并使用此来决定下一步是很诱人的。然而，如果在处理中途标志被翻转，这可能会导致问题。</p><p>如果标志被设置为 <code>normalize-first</code>，则批次从规范化服务开始。在该服务完成处理之前，有人翻转了标志以启用 <code>relabel-first</code> 过程。当规范化服务完成处理时，它将评估 <code>process-order</code> 标志并使用 <code>relabel-first</code> 顺序，在该顺序中，规范化步骤后跟存储。这个数据批次应该被发送到重新标记服务，因为它还没有被重新标记，但它将被发送到存储服务。</p><p>这是一个需要在整个多个步骤中保持标志一致性的情况示例。标志应该为每个批次评估一次，并且该值应该在服务之间的调用中发送。</p><h2 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h2><p>在本指南中，我们涵盖了：</p><ul><li>使用代码引用在您的代码库中找到特性标志</li><li>何时以及如何重构以简化您的代码</li><li>如何通过标志提高代码质量</li></ul></div><script src=https://giscus.app/client.js data-repo=joey5403/joey5403 data-repo-id=R_kgDOGVP_hg data-category=General data-category-id=DIC_kwDOGVP_hs4ChjR9 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=dark data-lang=en crossorigin=anonymous async></script><footer class=post-footer><ul class=post-tags><li><a href=https://joeyzheng.tech/tags/feature-toggle/>Feature Toggle</a></li></ul><nav class=paginav><a class=prev href=https://joeyzheng.tech/posts/hexagonal-architecture-pattern/><span class=title>« Prev</span><br><span>Hexagonal architecture pattern</span>
</a><a class=next href=https://joeyzheng.tech/posts/feature-management-06/><span class=title>Next »</span><br><span>LaunchDarkly’s vision of feature management</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Improving flag usage in code on x" href="https://x.com/intent/tweet/?text=Improving%20flag%20usage%20in%20code&amp;url=https%3a%2f%2fjoeyzheng.tech%2fposts%2fimproving-flag-usage-in-code%2f&amp;hashtags=featuretoggle"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Improving flag usage in code on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjoeyzheng.tech%2fposts%2fimproving-flag-usage-in-code%2f&amp;title=Improving%20flag%20usage%20in%20code&amp;summary=Improving%20flag%20usage%20in%20code&amp;source=https%3a%2f%2fjoeyzheng.tech%2fposts%2fimproving-flag-usage-in-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Improving flag usage in code on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjoeyzheng.tech%2fposts%2fimproving-flag-usage-in-code%2f&title=Improving%20flag%20usage%20in%20code"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Improving flag usage in code on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjoeyzheng.tech%2fposts%2fimproving-flag-usage-in-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Improving flag usage in code on whatsapp" href="https://api.whatsapp.com/send?text=Improving%20flag%20usage%20in%20code%20-%20https%3a%2f%2fjoeyzheng.tech%2fposts%2fimproving-flag-usage-in-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Improving flag usage in code on telegram" href="https://telegram.me/share/url?text=Improving%20flag%20usage%20in%20code&amp;url=https%3a%2f%2fjoeyzheng.tech%2fposts%2fimproving-flag-usage-in-code%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Improving flag usage in code on ycombinator" href="https://news.ycombinator.com/submitlink?t=Improving%20flag%20usage%20in%20code&u=https%3a%2f%2fjoeyzheng.tech%2fposts%2fimproving-flag-usage-in-code%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://joeyzheng.tech/>黄庄以北</a></span> ·
<span><img src="https://count.getloli.com/@joey5403.blog?name=joey5403.blog&theme=sketch-2&padding=7&offset=0&align=top&scale=1&pixelated=1&darkmode=auto">
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><br></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>